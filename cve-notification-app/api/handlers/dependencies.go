package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/api/models"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/api/utils"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services"
)

// UserDependenciesHandler handles the user dependencies route
func UserDependenciesHandler(w http.ResponseWriter, r *http.Request) {
	username := r.Context().Value("username").(string)
	library, client, ctx, err := utils.GetMongoConnection()
	if err != nil {
		http.Error(w, "Error connecting to MongoDB", http.StatusInternalServerError)
		return
	}

	userDependencies, err := library.GetUserDependencies(ctx, client, username)
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error getting user dependencies"}, http.StatusInternalServerError)
		return
	}

	utils.WriteResponse(w, models.UserDependenciesResponse{UserDependencies: userDependencies}, http.StatusOK)
}

// UpdateDependenciesHandler handles the update dependencies route
func UpdateDependenciesHandler(w http.ResponseWriter, r *http.Request) {
	username := r.Context().Value("username").(string)
	var userDependencies []services.DependencyWithIntegration
	_ = json.NewDecoder(r.Body).Decode(&userDependencies)

	library, client, ctx, err := utils.GetMongoConnection()
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error connecting to MongoDB"}, http.StatusInternalServerError)
		return
	}

	userExists, _, err := library.FindUserByUsername(ctx, client, username)
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error updating user dependencies"}, http.StatusInternalServerError)
		return
	}

	if !userExists {
		utils.WriteResponse(w, models.MessageResponse{Message: "User does not exist"}, http.StatusNotFound)
		return
	}

	err = library.UpdateUserDependencies(ctx, client, username, userDependencies)
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error updating user dependencies: " + err.Error()}, http.StatusBadRequest)
		return
	}

	utils.WriteResponse(w, models.MessageResponse{Message: "User dependencies updated successfully"}, http.StatusOK)
}

// CVEHandler handles the CSV route
func CVEHandler(w http.ResponseWriter, r *http.Request) {
	library, client, ctx, err := utils.GetMongoConnection()
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error connecting to MongoDB"}, http.StatusInternalServerError)
		return
	}

	cves, err := library.GetTrackedDependencies(ctx, client)
	if err != nil {
		utils.WriteResponse(w, models.MessageResponse{Message: "Error getting unique dependencies"}, http.StatusInternalServerError)
		return
	}

	trackedCves := make([]models.TrackedCVE, 0)

	for _, cve := range cves {
		trackedCves = append(trackedCves, models.TrackedCVE{
			Product: cve.Product,
			Vendor:  cve.Vendor,
		})
	}

	utils.WriteResponse(w, models.CVEResponse{CVES: trackedCves}, http.StatusOK)
}
