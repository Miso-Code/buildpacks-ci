// Code generated by counterfeiter. DO NOT EDIT.
package servicesfakes

import (
	"context"
	"sync"

	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services"
	"go.mongodb.org/mongo-driver/mongo"
)

type FakeMongoLibraryInterface struct {
	AddTrackedDependenciesStub        func(context.Context, *mongo.Client, []services.Dependency) error
	addTrackedDependenciesMutex       sync.RWMutex
	addTrackedDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 []services.Dependency
	}
	addTrackedDependenciesReturns struct {
		result1 error
	}
	addTrackedDependenciesReturnsOnCall map[int]struct {
		result1 error
	}
	CVEExistsStub        func(context.Context, *mongo.Client, string) (bool, error)
	cVEExistsMutex       sync.RWMutex
	cVEExistsArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}
	cVEExistsReturns struct {
		result1 bool
		result2 error
	}
	cVEExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateCVEStub        func(context.Context, *mongo.Client, *services.CVE) error
	createCVEMutex       sync.RWMutex
	createCVEArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 *services.CVE
	}
	createCVEReturns struct {
		result1 error
	}
	createCVEReturnsOnCall map[int]struct {
		result1 error
	}
	DisconnectMongoClientStub        func(*mongo.Client, context.Context) error
	disconnectMongoClientMutex       sync.RWMutex
	disconnectMongoClientArgsForCall []struct {
		arg1 *mongo.Client
		arg2 context.Context
	}
	disconnectMongoClientReturns struct {
		result1 error
	}
	disconnectMongoClientReturnsOnCall map[int]struct {
		result1 error
	}
	FindCVEStub        func(context.Context, *mongo.Client, string) (services.CVE, error)
	findCVEMutex       sync.RWMutex
	findCVEArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}
	findCVEReturns struct {
		result1 services.CVE
		result2 error
	}
	findCVEReturnsOnCall map[int]struct {
		result1 services.CVE
		result2 error
	}
	FindUserByUsernameStub        func(context.Context, *mongo.Client, string) (bool, services.User, error)
	findUserByUsernameMutex       sync.RWMutex
	findUserByUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}
	findUserByUsernameReturns struct {
		result1 bool
		result2 services.User
		result3 error
	}
	findUserByUsernameReturnsOnCall map[int]struct {
		result1 bool
		result2 services.User
		result3 error
	}
	GetAllCVEsStub        func(context.Context, *mongo.Client) ([]services.CVE, error)
	getAllCVEsMutex       sync.RWMutex
	getAllCVEsArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
	}
	getAllCVEsReturns struct {
		result1 []services.CVE
		result2 error
	}
	getAllCVEsReturnsOnCall map[int]struct {
		result1 []services.CVE
		result2 error
	}
	GetMongoClientStub        func() (*mongo.Client, context.Context, error)
	getMongoClientMutex       sync.RWMutex
	getMongoClientArgsForCall []struct {
	}
	getMongoClientReturns struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}
	getMongoClientReturnsOnCall map[int]struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}
	GetMongoCollectionStub        func(*mongo.Client, string, string) *mongo.Collection
	getMongoCollectionMutex       sync.RWMutex
	getMongoCollectionArgsForCall []struct {
		arg1 *mongo.Client
		arg2 string
		arg3 string
	}
	getMongoCollectionReturns struct {
		result1 *mongo.Collection
	}
	getMongoCollectionReturnsOnCall map[int]struct {
		result1 *mongo.Collection
	}
	GetTrackedDependenciesStub        func(context.Context, *mongo.Client) ([]services.Dependency, error)
	getTrackedDependenciesMutex       sync.RWMutex
	getTrackedDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
	}
	getTrackedDependenciesReturns struct {
		result1 []services.Dependency
		result2 error
	}
	getTrackedDependenciesReturnsOnCall map[int]struct {
		result1 []services.Dependency
		result2 error
	}
	GetUniqueDependenciesStub        func(context.Context, *mongo.Client) ([]services.CVE, error)
	getUniqueDependenciesMutex       sync.RWMutex
	getUniqueDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
	}
	getUniqueDependenciesReturns struct {
		result1 []services.CVE
		result2 error
	}
	getUniqueDependenciesReturnsOnCall map[int]struct {
		result1 []services.CVE
		result2 error
	}
	GetUserDependenciesStub        func(context.Context, *mongo.Client, string) (services.UserDependencies, error)
	getUserDependenciesMutex       sync.RWMutex
	getUserDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}
	getUserDependenciesReturns struct {
		result1 services.UserDependencies
		result2 error
	}
	getUserDependenciesReturnsOnCall map[int]struct {
		result1 services.UserDependencies
		result2 error
	}
	RegisterUserStub        func(context.Context, *mongo.Client, services.User) error
	registerUserMutex       sync.RWMutex
	registerUserArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 services.User
	}
	registerUserReturns struct {
		result1 error
	}
	registerUserReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllCVEsStub        func(context.Context, *mongo.Client, string) error
	removeAllCVEsMutex       sync.RWMutex
	removeAllCVEsArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}
	removeAllCVEsReturns struct {
		result1 error
	}
	removeAllCVEsReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveTrackedDependenciesStub        func(context.Context, *mongo.Client, []services.Dependency) error
	removeTrackedDependenciesMutex       sync.RWMutex
	removeTrackedDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 []services.Dependency
	}
	removeTrackedDependenciesReturns struct {
		result1 error
	}
	removeTrackedDependenciesReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUserDependenciesStub        func(context.Context, *mongo.Client, string, []services.DependencyWithIntegration) error
	updateUserDependenciesMutex       sync.RWMutex
	updateUserDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
		arg4 []services.DependencyWithIntegration
	}
	updateUserDependenciesReturns struct {
		result1 error
	}
	updateUserDependenciesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependencies(arg1 context.Context, arg2 *mongo.Client, arg3 []services.Dependency) error {
	var arg3Copy []services.Dependency
	if arg3 != nil {
		arg3Copy = make([]services.Dependency, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addTrackedDependenciesMutex.Lock()
	ret, specificReturn := fake.addTrackedDependenciesReturnsOnCall[len(fake.addTrackedDependenciesArgsForCall)]
	fake.addTrackedDependenciesArgsForCall = append(fake.addTrackedDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 []services.Dependency
	}{arg1, arg2, arg3Copy})
	stub := fake.AddTrackedDependenciesStub
	fakeReturns := fake.addTrackedDependenciesReturns
	fake.recordInvocation("AddTrackedDependencies", []interface{}{arg1, arg2, arg3Copy})
	fake.addTrackedDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependenciesCallCount() int {
	fake.addTrackedDependenciesMutex.RLock()
	defer fake.addTrackedDependenciesMutex.RUnlock()
	return len(fake.addTrackedDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependenciesCalls(stub func(context.Context, *mongo.Client, []services.Dependency) error) {
	fake.addTrackedDependenciesMutex.Lock()
	defer fake.addTrackedDependenciesMutex.Unlock()
	fake.AddTrackedDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependenciesArgsForCall(i int) (context.Context, *mongo.Client, []services.Dependency) {
	fake.addTrackedDependenciesMutex.RLock()
	defer fake.addTrackedDependenciesMutex.RUnlock()
	argsForCall := fake.addTrackedDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependenciesReturns(result1 error) {
	fake.addTrackedDependenciesMutex.Lock()
	defer fake.addTrackedDependenciesMutex.Unlock()
	fake.AddTrackedDependenciesStub = nil
	fake.addTrackedDependenciesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) AddTrackedDependenciesReturnsOnCall(i int, result1 error) {
	fake.addTrackedDependenciesMutex.Lock()
	defer fake.addTrackedDependenciesMutex.Unlock()
	fake.AddTrackedDependenciesStub = nil
	if fake.addTrackedDependenciesReturnsOnCall == nil {
		fake.addTrackedDependenciesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addTrackedDependenciesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) CVEExists(arg1 context.Context, arg2 *mongo.Client, arg3 string) (bool, error) {
	fake.cVEExistsMutex.Lock()
	ret, specificReturn := fake.cVEExistsReturnsOnCall[len(fake.cVEExistsArgsForCall)]
	fake.cVEExistsArgsForCall = append(fake.cVEExistsArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CVEExistsStub
	fakeReturns := fake.cVEExistsReturns
	fake.recordInvocation("CVEExists", []interface{}{arg1, arg2, arg3})
	fake.cVEExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) CVEExistsCallCount() int {
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	return len(fake.cVEExistsArgsForCall)
}

func (fake *FakeMongoLibraryInterface) CVEExistsCalls(stub func(context.Context, *mongo.Client, string) (bool, error)) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = stub
}

func (fake *FakeMongoLibraryInterface) CVEExistsArgsForCall(i int) (context.Context, *mongo.Client, string) {
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	argsForCall := fake.cVEExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) CVEExistsReturns(result1 bool, result2 error) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = nil
	fake.cVEExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) CVEExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = nil
	if fake.cVEExistsReturnsOnCall == nil {
		fake.cVEExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cVEExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) CreateCVE(arg1 context.Context, arg2 *mongo.Client, arg3 *services.CVE) error {
	fake.createCVEMutex.Lock()
	ret, specificReturn := fake.createCVEReturnsOnCall[len(fake.createCVEArgsForCall)]
	fake.createCVEArgsForCall = append(fake.createCVEArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 *services.CVE
	}{arg1, arg2, arg3})
	stub := fake.CreateCVEStub
	fakeReturns := fake.createCVEReturns
	fake.recordInvocation("CreateCVE", []interface{}{arg1, arg2, arg3})
	fake.createCVEMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) CreateCVECallCount() int {
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	return len(fake.createCVEArgsForCall)
}

func (fake *FakeMongoLibraryInterface) CreateCVECalls(stub func(context.Context, *mongo.Client, *services.CVE) error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = stub
}

func (fake *FakeMongoLibraryInterface) CreateCVEArgsForCall(i int) (context.Context, *mongo.Client, *services.CVE) {
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	argsForCall := fake.createCVEArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) CreateCVEReturns(result1 error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = nil
	fake.createCVEReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) CreateCVEReturnsOnCall(i int, result1 error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = nil
	if fake.createCVEReturnsOnCall == nil {
		fake.createCVEReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createCVEReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClient(arg1 *mongo.Client, arg2 context.Context) error {
	fake.disconnectMongoClientMutex.Lock()
	ret, specificReturn := fake.disconnectMongoClientReturnsOnCall[len(fake.disconnectMongoClientArgsForCall)]
	fake.disconnectMongoClientArgsForCall = append(fake.disconnectMongoClientArgsForCall, struct {
		arg1 *mongo.Client
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.DisconnectMongoClientStub
	fakeReturns := fake.disconnectMongoClientReturns
	fake.recordInvocation("DisconnectMongoClient", []interface{}{arg1, arg2})
	fake.disconnectMongoClientMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClientCallCount() int {
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	return len(fake.disconnectMongoClientArgsForCall)
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClientCalls(stub func(*mongo.Client, context.Context) error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = stub
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClientArgsForCall(i int) (*mongo.Client, context.Context) {
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	argsForCall := fake.disconnectMongoClientArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClientReturns(result1 error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = nil
	fake.disconnectMongoClientReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) DisconnectMongoClientReturnsOnCall(i int, result1 error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = nil
	if fake.disconnectMongoClientReturnsOnCall == nil {
		fake.disconnectMongoClientReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disconnectMongoClientReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) FindCVE(arg1 context.Context, arg2 *mongo.Client, arg3 string) (services.CVE, error) {
	fake.findCVEMutex.Lock()
	ret, specificReturn := fake.findCVEReturnsOnCall[len(fake.findCVEArgsForCall)]
	fake.findCVEArgsForCall = append(fake.findCVEArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindCVEStub
	fakeReturns := fake.findCVEReturns
	fake.recordInvocation("FindCVE", []interface{}{arg1, arg2, arg3})
	fake.findCVEMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) FindCVECallCount() int {
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	return len(fake.findCVEArgsForCall)
}

func (fake *FakeMongoLibraryInterface) FindCVECalls(stub func(context.Context, *mongo.Client, string) (services.CVE, error)) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = stub
}

func (fake *FakeMongoLibraryInterface) FindCVEArgsForCall(i int) (context.Context, *mongo.Client, string) {
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	argsForCall := fake.findCVEArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) FindCVEReturns(result1 services.CVE, result2 error) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = nil
	fake.findCVEReturns = struct {
		result1 services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) FindCVEReturnsOnCall(i int, result1 services.CVE, result2 error) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = nil
	if fake.findCVEReturnsOnCall == nil {
		fake.findCVEReturnsOnCall = make(map[int]struct {
			result1 services.CVE
			result2 error
		})
	}
	fake.findCVEReturnsOnCall[i] = struct {
		result1 services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) FindUserByUsername(arg1 context.Context, arg2 *mongo.Client, arg3 string) (bool, services.User, error) {
	fake.findUserByUsernameMutex.Lock()
	ret, specificReturn := fake.findUserByUsernameReturnsOnCall[len(fake.findUserByUsernameArgsForCall)]
	fake.findUserByUsernameArgsForCall = append(fake.findUserByUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FindUserByUsernameStub
	fakeReturns := fake.findUserByUsernameReturns
	fake.recordInvocation("FindUserByUsername", []interface{}{arg1, arg2, arg3})
	fake.findUserByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMongoLibraryInterface) FindUserByUsernameCallCount() int {
	fake.findUserByUsernameMutex.RLock()
	defer fake.findUserByUsernameMutex.RUnlock()
	return len(fake.findUserByUsernameArgsForCall)
}

func (fake *FakeMongoLibraryInterface) FindUserByUsernameCalls(stub func(context.Context, *mongo.Client, string) (bool, services.User, error)) {
	fake.findUserByUsernameMutex.Lock()
	defer fake.findUserByUsernameMutex.Unlock()
	fake.FindUserByUsernameStub = stub
}

func (fake *FakeMongoLibraryInterface) FindUserByUsernameArgsForCall(i int) (context.Context, *mongo.Client, string) {
	fake.findUserByUsernameMutex.RLock()
	defer fake.findUserByUsernameMutex.RUnlock()
	argsForCall := fake.findUserByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) FindUserByUsernameReturns(result1 bool, result2 services.User, result3 error) {
	fake.findUserByUsernameMutex.Lock()
	defer fake.findUserByUsernameMutex.Unlock()
	fake.FindUserByUsernameStub = nil
	fake.findUserByUsernameReturns = struct {
		result1 bool
		result2 services.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoLibraryInterface) FindUserByUsernameReturnsOnCall(i int, result1 bool, result2 services.User, result3 error) {
	fake.findUserByUsernameMutex.Lock()
	defer fake.findUserByUsernameMutex.Unlock()
	fake.FindUserByUsernameStub = nil
	if fake.findUserByUsernameReturnsOnCall == nil {
		fake.findUserByUsernameReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 services.User
			result3 error
		})
	}
	fake.findUserByUsernameReturnsOnCall[i] = struct {
		result1 bool
		result2 services.User
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoLibraryInterface) GetAllCVEs(arg1 context.Context, arg2 *mongo.Client) ([]services.CVE, error) {
	fake.getAllCVEsMutex.Lock()
	ret, specificReturn := fake.getAllCVEsReturnsOnCall[len(fake.getAllCVEsArgsForCall)]
	fake.getAllCVEsArgsForCall = append(fake.getAllCVEsArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
	}{arg1, arg2})
	stub := fake.GetAllCVEsStub
	fakeReturns := fake.getAllCVEsReturns
	fake.recordInvocation("GetAllCVEs", []interface{}{arg1, arg2})
	fake.getAllCVEsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) GetAllCVEsCallCount() int {
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	return len(fake.getAllCVEsArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetAllCVEsCalls(stub func(context.Context, *mongo.Client) ([]services.CVE, error)) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = stub
}

func (fake *FakeMongoLibraryInterface) GetAllCVEsArgsForCall(i int) (context.Context, *mongo.Client) {
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	argsForCall := fake.getAllCVEsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoLibraryInterface) GetAllCVEsReturns(result1 []services.CVE, result2 error) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = nil
	fake.getAllCVEsReturns = struct {
		result1 []services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetAllCVEsReturnsOnCall(i int, result1 []services.CVE, result2 error) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = nil
	if fake.getAllCVEsReturnsOnCall == nil {
		fake.getAllCVEsReturnsOnCall = make(map[int]struct {
			result1 []services.CVE
			result2 error
		})
	}
	fake.getAllCVEsReturnsOnCall[i] = struct {
		result1 []services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetMongoClient() (*mongo.Client, context.Context, error) {
	fake.getMongoClientMutex.Lock()
	ret, specificReturn := fake.getMongoClientReturnsOnCall[len(fake.getMongoClientArgsForCall)]
	fake.getMongoClientArgsForCall = append(fake.getMongoClientArgsForCall, struct {
	}{})
	stub := fake.GetMongoClientStub
	fakeReturns := fake.getMongoClientReturns
	fake.recordInvocation("GetMongoClient", []interface{}{})
	fake.getMongoClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMongoLibraryInterface) GetMongoClientCallCount() int {
	fake.getMongoClientMutex.RLock()
	defer fake.getMongoClientMutex.RUnlock()
	return len(fake.getMongoClientArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetMongoClientCalls(stub func() (*mongo.Client, context.Context, error)) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = stub
}

func (fake *FakeMongoLibraryInterface) GetMongoClientReturns(result1 *mongo.Client, result2 context.Context, result3 error) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = nil
	fake.getMongoClientReturns = struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoLibraryInterface) GetMongoClientReturnsOnCall(i int, result1 *mongo.Client, result2 context.Context, result3 error) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = nil
	if fake.getMongoClientReturnsOnCall == nil {
		fake.getMongoClientReturnsOnCall = make(map[int]struct {
			result1 *mongo.Client
			result2 context.Context
			result3 error
		})
	}
	fake.getMongoClientReturnsOnCall[i] = struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoLibraryInterface) GetMongoCollection(arg1 *mongo.Client, arg2 string, arg3 string) *mongo.Collection {
	fake.getMongoCollectionMutex.Lock()
	ret, specificReturn := fake.getMongoCollectionReturnsOnCall[len(fake.getMongoCollectionArgsForCall)]
	fake.getMongoCollectionArgsForCall = append(fake.getMongoCollectionArgsForCall, struct {
		arg1 *mongo.Client
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetMongoCollectionStub
	fakeReturns := fake.getMongoCollectionReturns
	fake.recordInvocation("GetMongoCollection", []interface{}{arg1, arg2, arg3})
	fake.getMongoCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) GetMongoCollectionCallCount() int {
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	return len(fake.getMongoCollectionArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetMongoCollectionCalls(stub func(*mongo.Client, string, string) *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = stub
}

func (fake *FakeMongoLibraryInterface) GetMongoCollectionArgsForCall(i int) (*mongo.Client, string, string) {
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	argsForCall := fake.getMongoCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) GetMongoCollectionReturns(result1 *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = nil
	fake.getMongoCollectionReturns = struct {
		result1 *mongo.Collection
	}{result1}
}

func (fake *FakeMongoLibraryInterface) GetMongoCollectionReturnsOnCall(i int, result1 *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = nil
	if fake.getMongoCollectionReturnsOnCall == nil {
		fake.getMongoCollectionReturnsOnCall = make(map[int]struct {
			result1 *mongo.Collection
		})
	}
	fake.getMongoCollectionReturnsOnCall[i] = struct {
		result1 *mongo.Collection
	}{result1}
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependencies(arg1 context.Context, arg2 *mongo.Client) ([]services.Dependency, error) {
	fake.getTrackedDependenciesMutex.Lock()
	ret, specificReturn := fake.getTrackedDependenciesReturnsOnCall[len(fake.getTrackedDependenciesArgsForCall)]
	fake.getTrackedDependenciesArgsForCall = append(fake.getTrackedDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
	}{arg1, arg2})
	stub := fake.GetTrackedDependenciesStub
	fakeReturns := fake.getTrackedDependenciesReturns
	fake.recordInvocation("GetTrackedDependencies", []interface{}{arg1, arg2})
	fake.getTrackedDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependenciesCallCount() int {
	fake.getTrackedDependenciesMutex.RLock()
	defer fake.getTrackedDependenciesMutex.RUnlock()
	return len(fake.getTrackedDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependenciesCalls(stub func(context.Context, *mongo.Client) ([]services.Dependency, error)) {
	fake.getTrackedDependenciesMutex.Lock()
	defer fake.getTrackedDependenciesMutex.Unlock()
	fake.GetTrackedDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependenciesArgsForCall(i int) (context.Context, *mongo.Client) {
	fake.getTrackedDependenciesMutex.RLock()
	defer fake.getTrackedDependenciesMutex.RUnlock()
	argsForCall := fake.getTrackedDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependenciesReturns(result1 []services.Dependency, result2 error) {
	fake.getTrackedDependenciesMutex.Lock()
	defer fake.getTrackedDependenciesMutex.Unlock()
	fake.GetTrackedDependenciesStub = nil
	fake.getTrackedDependenciesReturns = struct {
		result1 []services.Dependency
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetTrackedDependenciesReturnsOnCall(i int, result1 []services.Dependency, result2 error) {
	fake.getTrackedDependenciesMutex.Lock()
	defer fake.getTrackedDependenciesMutex.Unlock()
	fake.GetTrackedDependenciesStub = nil
	if fake.getTrackedDependenciesReturnsOnCall == nil {
		fake.getTrackedDependenciesReturnsOnCall = make(map[int]struct {
			result1 []services.Dependency
			result2 error
		})
	}
	fake.getTrackedDependenciesReturnsOnCall[i] = struct {
		result1 []services.Dependency
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependencies(arg1 context.Context, arg2 *mongo.Client) ([]services.CVE, error) {
	fake.getUniqueDependenciesMutex.Lock()
	ret, specificReturn := fake.getUniqueDependenciesReturnsOnCall[len(fake.getUniqueDependenciesArgsForCall)]
	fake.getUniqueDependenciesArgsForCall = append(fake.getUniqueDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
	}{arg1, arg2})
	stub := fake.GetUniqueDependenciesStub
	fakeReturns := fake.getUniqueDependenciesReturns
	fake.recordInvocation("GetUniqueDependencies", []interface{}{arg1, arg2})
	fake.getUniqueDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependenciesCallCount() int {
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	return len(fake.getUniqueDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependenciesCalls(stub func(context.Context, *mongo.Client) ([]services.CVE, error)) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependenciesArgsForCall(i int) (context.Context, *mongo.Client) {
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	argsForCall := fake.getUniqueDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependenciesReturns(result1 []services.CVE, result2 error) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = nil
	fake.getUniqueDependenciesReturns = struct {
		result1 []services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetUniqueDependenciesReturnsOnCall(i int, result1 []services.CVE, result2 error) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = nil
	if fake.getUniqueDependenciesReturnsOnCall == nil {
		fake.getUniqueDependenciesReturnsOnCall = make(map[int]struct {
			result1 []services.CVE
			result2 error
		})
	}
	fake.getUniqueDependenciesReturnsOnCall[i] = struct {
		result1 []services.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetUserDependencies(arg1 context.Context, arg2 *mongo.Client, arg3 string) (services.UserDependencies, error) {
	fake.getUserDependenciesMutex.Lock()
	ret, specificReturn := fake.getUserDependenciesReturnsOnCall[len(fake.getUserDependenciesArgsForCall)]
	fake.getUserDependenciesArgsForCall = append(fake.getUserDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetUserDependenciesStub
	fakeReturns := fake.getUserDependenciesReturns
	fake.recordInvocation("GetUserDependencies", []interface{}{arg1, arg2, arg3})
	fake.getUserDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoLibraryInterface) GetUserDependenciesCallCount() int {
	fake.getUserDependenciesMutex.RLock()
	defer fake.getUserDependenciesMutex.RUnlock()
	return len(fake.getUserDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) GetUserDependenciesCalls(stub func(context.Context, *mongo.Client, string) (services.UserDependencies, error)) {
	fake.getUserDependenciesMutex.Lock()
	defer fake.getUserDependenciesMutex.Unlock()
	fake.GetUserDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) GetUserDependenciesArgsForCall(i int) (context.Context, *mongo.Client, string) {
	fake.getUserDependenciesMutex.RLock()
	defer fake.getUserDependenciesMutex.RUnlock()
	argsForCall := fake.getUserDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) GetUserDependenciesReturns(result1 services.UserDependencies, result2 error) {
	fake.getUserDependenciesMutex.Lock()
	defer fake.getUserDependenciesMutex.Unlock()
	fake.GetUserDependenciesStub = nil
	fake.getUserDependenciesReturns = struct {
		result1 services.UserDependencies
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) GetUserDependenciesReturnsOnCall(i int, result1 services.UserDependencies, result2 error) {
	fake.getUserDependenciesMutex.Lock()
	defer fake.getUserDependenciesMutex.Unlock()
	fake.GetUserDependenciesStub = nil
	if fake.getUserDependenciesReturnsOnCall == nil {
		fake.getUserDependenciesReturnsOnCall = make(map[int]struct {
			result1 services.UserDependencies
			result2 error
		})
	}
	fake.getUserDependenciesReturnsOnCall[i] = struct {
		result1 services.UserDependencies
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoLibraryInterface) RegisterUser(arg1 context.Context, arg2 *mongo.Client, arg3 services.User) error {
	fake.registerUserMutex.Lock()
	ret, specificReturn := fake.registerUserReturnsOnCall[len(fake.registerUserArgsForCall)]
	fake.registerUserArgsForCall = append(fake.registerUserArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 services.User
	}{arg1, arg2, arg3})
	stub := fake.RegisterUserStub
	fakeReturns := fake.registerUserReturns
	fake.recordInvocation("RegisterUser", []interface{}{arg1, arg2, arg3})
	fake.registerUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) RegisterUserCallCount() int {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	return len(fake.registerUserArgsForCall)
}

func (fake *FakeMongoLibraryInterface) RegisterUserCalls(stub func(context.Context, *mongo.Client, services.User) error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = stub
}

func (fake *FakeMongoLibraryInterface) RegisterUserArgsForCall(i int) (context.Context, *mongo.Client, services.User) {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	argsForCall := fake.registerUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) RegisterUserReturns(result1 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	fake.registerUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) RegisterUserReturnsOnCall(i int, result1 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	if fake.registerUserReturnsOnCall == nil {
		fake.registerUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEs(arg1 context.Context, arg2 *mongo.Client, arg3 string) error {
	fake.removeAllCVEsMutex.Lock()
	ret, specificReturn := fake.removeAllCVEsReturnsOnCall[len(fake.removeAllCVEsArgsForCall)]
	fake.removeAllCVEsArgsForCall = append(fake.removeAllCVEsArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RemoveAllCVEsStub
	fakeReturns := fake.removeAllCVEsReturns
	fake.recordInvocation("RemoveAllCVEs", []interface{}{arg1, arg2, arg3})
	fake.removeAllCVEsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEsCallCount() int {
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	return len(fake.removeAllCVEsArgsForCall)
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEsCalls(stub func(context.Context, *mongo.Client, string) error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = stub
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEsArgsForCall(i int) (context.Context, *mongo.Client, string) {
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	argsForCall := fake.removeAllCVEsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEsReturns(result1 error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = nil
	fake.removeAllCVEsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) RemoveAllCVEsReturnsOnCall(i int, result1 error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = nil
	if fake.removeAllCVEsReturnsOnCall == nil {
		fake.removeAllCVEsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllCVEsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependencies(arg1 context.Context, arg2 *mongo.Client, arg3 []services.Dependency) error {
	var arg3Copy []services.Dependency
	if arg3 != nil {
		arg3Copy = make([]services.Dependency, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.removeTrackedDependenciesMutex.Lock()
	ret, specificReturn := fake.removeTrackedDependenciesReturnsOnCall[len(fake.removeTrackedDependenciesArgsForCall)]
	fake.removeTrackedDependenciesArgsForCall = append(fake.removeTrackedDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 []services.Dependency
	}{arg1, arg2, arg3Copy})
	stub := fake.RemoveTrackedDependenciesStub
	fakeReturns := fake.removeTrackedDependenciesReturns
	fake.recordInvocation("RemoveTrackedDependencies", []interface{}{arg1, arg2, arg3Copy})
	fake.removeTrackedDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependenciesCallCount() int {
	fake.removeTrackedDependenciesMutex.RLock()
	defer fake.removeTrackedDependenciesMutex.RUnlock()
	return len(fake.removeTrackedDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependenciesCalls(stub func(context.Context, *mongo.Client, []services.Dependency) error) {
	fake.removeTrackedDependenciesMutex.Lock()
	defer fake.removeTrackedDependenciesMutex.Unlock()
	fake.RemoveTrackedDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependenciesArgsForCall(i int) (context.Context, *mongo.Client, []services.Dependency) {
	fake.removeTrackedDependenciesMutex.RLock()
	defer fake.removeTrackedDependenciesMutex.RUnlock()
	argsForCall := fake.removeTrackedDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependenciesReturns(result1 error) {
	fake.removeTrackedDependenciesMutex.Lock()
	defer fake.removeTrackedDependenciesMutex.Unlock()
	fake.RemoveTrackedDependenciesStub = nil
	fake.removeTrackedDependenciesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) RemoveTrackedDependenciesReturnsOnCall(i int, result1 error) {
	fake.removeTrackedDependenciesMutex.Lock()
	defer fake.removeTrackedDependenciesMutex.Unlock()
	fake.RemoveTrackedDependenciesStub = nil
	if fake.removeTrackedDependenciesReturnsOnCall == nil {
		fake.removeTrackedDependenciesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeTrackedDependenciesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependencies(arg1 context.Context, arg2 *mongo.Client, arg3 string, arg4 []services.DependencyWithIntegration) error {
	var arg4Copy []services.DependencyWithIntegration
	if arg4 != nil {
		arg4Copy = make([]services.DependencyWithIntegration, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateUserDependenciesMutex.Lock()
	ret, specificReturn := fake.updateUserDependenciesReturnsOnCall[len(fake.updateUserDependenciesArgsForCall)]
	fake.updateUserDependenciesArgsForCall = append(fake.updateUserDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Client
		arg3 string
		arg4 []services.DependencyWithIntegration
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateUserDependenciesStub
	fakeReturns := fake.updateUserDependenciesReturns
	fake.recordInvocation("UpdateUserDependencies", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateUserDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependenciesCallCount() int {
	fake.updateUserDependenciesMutex.RLock()
	defer fake.updateUserDependenciesMutex.RUnlock()
	return len(fake.updateUserDependenciesArgsForCall)
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependenciesCalls(stub func(context.Context, *mongo.Client, string, []services.DependencyWithIntegration) error) {
	fake.updateUserDependenciesMutex.Lock()
	defer fake.updateUserDependenciesMutex.Unlock()
	fake.UpdateUserDependenciesStub = stub
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependenciesArgsForCall(i int) (context.Context, *mongo.Client, string, []services.DependencyWithIntegration) {
	fake.updateUserDependenciesMutex.RLock()
	defer fake.updateUserDependenciesMutex.RUnlock()
	argsForCall := fake.updateUserDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependenciesReturns(result1 error) {
	fake.updateUserDependenciesMutex.Lock()
	defer fake.updateUserDependenciesMutex.Unlock()
	fake.UpdateUserDependenciesStub = nil
	fake.updateUserDependenciesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) UpdateUserDependenciesReturnsOnCall(i int, result1 error) {
	fake.updateUserDependenciesMutex.Lock()
	defer fake.updateUserDependenciesMutex.Unlock()
	fake.UpdateUserDependenciesStub = nil
	if fake.updateUserDependenciesReturnsOnCall == nil {
		fake.updateUserDependenciesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUserDependenciesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoLibraryInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addTrackedDependenciesMutex.RLock()
	defer fake.addTrackedDependenciesMutex.RUnlock()
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	fake.findUserByUsernameMutex.RLock()
	defer fake.findUserByUsernameMutex.RUnlock()
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	fake.getMongoClientMutex.RLock()
	defer fake.getMongoClientMutex.RUnlock()
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	fake.getTrackedDependenciesMutex.RLock()
	defer fake.getTrackedDependenciesMutex.RUnlock()
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	fake.getUserDependenciesMutex.RLock()
	defer fake.getUserDependenciesMutex.RUnlock()
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	fake.removeTrackedDependenciesMutex.RLock()
	defer fake.removeTrackedDependenciesMutex.RUnlock()
	fake.updateUserDependenciesMutex.RLock()
	defer fake.updateUserDependenciesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMongoLibraryInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ services.MongoLibraryInterface = new(FakeMongoLibraryInterface)
