package services

import (
	"context"
	"errors"
	"fmt"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . MongoLibraryInterface
type MongoLibraryInterface interface {
	GetMongoClient() (*mongo.Client, context.Context, error)
	DisconnectMongoClient(client *mongo.Client, ctx context.Context) error
	GetMongoCollection(client *mongo.Client, database, collection string) *mongo.Collection
	CreateCVE(ctx context.Context, client *mongo.Client, cve *CVE) error
	GetUniqueDependencies(ctx context.Context, client *mongo.Client) ([]CVE, error)
	FindCVE(ctx context.Context, client *mongo.Client, product string) (CVE, error)
	RemoveAllCVEs(ctx context.Context, client *mongo.Client, product string) error
	CVEExists(ctx context.Context, client *mongo.Client, cveId string) (bool, error)
	GetAllCVEs(ctx context.Context, client *mongo.Client) ([]CVE, error)
	GetTrackedDependencies(ctx context.Context, client *mongo.Client) ([]Dependency, error)
	AddTrackedDependencies(ctx context.Context, client *mongo.Client, dependencies []Dependency) error
	RemoveTrackedDependencies(ctx context.Context, client *mongo.Client, dependencies []Dependency) error
	RegisterUser(ctx context.Context, client *mongo.Client, user User) error
	FindUserByUsername(ctx context.Context, client *mongo.Client, username string) (bool, User, error)
	GetUserDependencies(ctx context.Context, client *mongo.Client, userId string) (UserDependencies, error)
	UpdateUserDependencies(ctx context.Context, client *mongo.Client, userId string, userDeps []DependencyWithIntegration) error
}

var DATABASE = "buildpacks"

type MongoLibrary struct {
	DbUri       string
	CtxDuration time.Duration
}

type CVE struct {
	ID          primitive.ObjectID `bson:"_id"`
	CreatedAt   time.Time          `bson:"created_at"`
	UpdatedAt   time.Time          `bson:"updated_at"`
	Vendor      string             `bson:"vendor"`
	Product     string             `bson:"product"`
	Severity    string             `bson:"severity"`
	CVEId       string             `bson:"cve_id"`
	Description string             `bson:"description"`
	Score       float64            `bson:"score"`
}

type User struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type Dependency struct {
	Id         string `json:"id" bson:"_id"`
	Dependency string `json:"dependency"`
	Product    string `json:"product"`
	Vendor     string `json:"vendor"`
}

type Integration struct {
	Type     string `json:"type"`
	Active   bool   `json:"active"`
	Settings string `json:"settings"`
}

type DependencyWithIntegration struct {
	DependencyId string      `json:"dependency_id"`
	Integration  Integration `json:"integration"`
}

type UserDependencies struct {
	UserID              string                      `json:"user_id" bson:"user_id"`
	DependenciesWithInt []DependencyWithIntegration `json:"dependencies_with_integration" bson:"dependencies_with_integration"`
}

func (mu MongoLibrary) GetMongoClient() (*mongo.Client, context.Context, error) {
	ctx, _ := context.WithTimeout(context.Background(), mu.CtxDuration)
	clientOptions := options.Client().SetTimeout(30 * time.Second).ApplyURI(mu.DbUri)
	client, err := mongo.Connect(ctx, clientOptions)
	if err != nil {
		return nil, nil, fmt.Errorf("error connecting to MongoDB\n%w", err)
	}

	return client, ctx, nil
}

func NewMongoLibrary(dbUri string) MongoLibrary {
	return MongoLibrary{
		DbUri:       dbUri,
		CtxDuration: 20 * time.Minute,
	}
}

func (mu MongoLibrary) GetMongoCollection(client *mongo.Client, database, collection string) *mongo.Collection {
	return client.Database(database).Collection(collection)
}

func (mu MongoLibrary) DisconnectMongoClient(client *mongo.Client, ctx context.Context) error {
	err := client.Disconnect(ctx)
	if err != nil {
		return fmt.Errorf("error disconnecting client\n%w", err)
	}

	return nil
}

func (mu MongoLibrary) CreateCVE(ctx context.Context, client *mongo.Client, cve *CVE) error {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	_, err := collection.InsertOne(ctx, cve)
	if err != nil {
		return fmt.Errorf("error creating a CVE\n%w", err)
	}

	return nil
}

func (mu MongoLibrary) GetUniqueDependencies(ctx context.Context, client *mongo.Client) ([]CVE, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	results, err := collection.Distinct(ctx, "product", bson.D{{}})
	if err != nil {
		return nil, fmt.Errorf("error getting unique CVEs query result\n%w", err)
	}

	deps := make([]CVE, 0, len(results))
	for _, result := range results {
		cve, err := mu.FindCVE(ctx, client, result.(string))
		if err != nil {
			return nil, err
		}
		deps = append(deps, cve)
	}

	return deps, nil
}

func (mu MongoLibrary) GetTrackedDependencies(ctx context.Context, client *mongo.Client) ([]Dependency, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "tracked")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	cursor, err := collection.Find(ctx, bson.D{})
	if err != nil {
		return nil, fmt.Errorf("error getting tracked CVEs query result\n%w", err)
	}

	var deps []Dependency
	err = cursor.All(ctx, &deps)
	if err != nil {
		return nil, fmt.Errorf("error getting tracked CVEs query result\n%w", err)
	}

	return deps, nil
}

func (mu MongoLibrary) AddTrackedDependencies(ctx context.Context, client *mongo.Client, dependencies []Dependency) error {
	collection := mu.GetMongoCollection(client, DATABASE, "tracked")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	for _, dep := range dependencies {
		_, err := collection.InsertOne(ctx, dep)
		if err != nil {
			return fmt.Errorf("error adding tracked dependency\n%w", err)
		}
	}

	return nil
}

func (mu MongoLibrary) RemoveTrackedDependencies(ctx context.Context, client *mongo.Client, dependencies []Dependency) error {
	collection := mu.GetMongoCollection(client, DATABASE, "tracked")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	for _, dep := range dependencies {
		_, err := collection.DeleteOne(ctx, bson.D{{"product", dep.Product}})
		if err != nil {
			return fmt.Errorf("error removing tracked dependency\n%w", err)
		}
	}

	return nil
}

func (mu MongoLibrary) FindCVE(ctx context.Context, client *mongo.Client, product string) (CVE, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	cve := CVE{}
	result := collection.FindOne(ctx, bson.D{{"product", product}})
	err := result.Decode(&cve)
	if err != nil {
		return CVE{}, err
	}

	return cve, nil
}

func (mu MongoLibrary) RemoveAllCVEs(ctx context.Context, client *mongo.Client, product string) error {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	_, err := collection.DeleteMany(ctx, bson.D{{"product", product}})
	if err != nil {
		return err
	}

	return nil
}

func (mu MongoLibrary) CVEExists(ctx context.Context, client *mongo.Client, cveId string) (bool, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	result, err := collection.CountDocuments(ctx, bson.D{{"cve_id", cveId}})
	if err != nil {
		return false, fmt.Errorf("error retrieving a CVE\n%w", err)
	}

	return result > 0, nil
}

func (mu MongoLibrary) GetAllCVEs(ctx context.Context, client *mongo.Client) ([]CVE, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "cves")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	cursor, err := collection.Find(ctx, bson.D{})
	if err != nil {
		return nil, fmt.Errorf("error retrieving all CVEs\n%w", err)
	}

	var cves []CVE
	for cursor.Next(ctx) {
		var cve CVE
		err = cursor.Decode(&cve)
		if err != nil {
			return nil, fmt.Errorf("error decoding CVE from database result\n%w", err)
		}
		cves = append(cves, cve)
	}

	return cves, nil
}

func (mu MongoLibrary) RegisterUser(ctx context.Context, client *mongo.Client, user User) error {
	collection := mu.GetMongoCollection(client, DATABASE, "users")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	_, err := collection.InsertOne(ctx, user)
	if err != nil {
		return fmt.Errorf("error registering user\n%w", err)
	}

	return nil
}

func (mu MongoLibrary) FindUserByUsername(ctx context.Context, client *mongo.Client, username string) (bool, User, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "users")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	var foundUser User
	err := collection.FindOne(ctx, bson.D{{"username", username}}).Decode(&foundUser)
	if err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return false, User{}, nil
		}
		return false, User{}, fmt.Errorf("error finding user by username: %w", err)
	}

	return true, foundUser, nil
}

func (mu MongoLibrary) GetUserDependencies(ctx context.Context, client *mongo.Client, userId string) (UserDependencies, error) {
	collection := mu.GetMongoCollection(client, DATABASE, "user_dependencies")

	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	var userDeps UserDependencies
	err := collection.FindOne(ctx, bson.M{"user_id": userId}).Decode(&userDeps)
	if err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return UserDependencies{}, nil
		}
		return UserDependencies{}, fmt.Errorf("error finding user dependencies: %w", err)
	}
	return userDeps, nil
}

func (mu MongoLibrary) UpdateUserDependencies(ctx context.Context, client *mongo.Client, userId string, userDeps []DependencyWithIntegration) error {
	ctx, cancel := context.WithTimeout(ctx, mu.CtxDuration)
	defer cancel()

	// Get the collections
	userDependenciesCollection := mu.GetMongoCollection(client, DATABASE, "user_dependencies")
	trackedCVEsCollection := mu.GetMongoCollection(client, DATABASE, "tracked")

	// Convert userDeps to a slice of DependencyId strings
	dependencyIds := make([]primitive.ObjectID, len(userDeps))
	for i, dep := range userDeps {
		objectId, err := primitive.ObjectIDFromHex(dep.DependencyId)
		if err != nil {
			return fmt.Errorf("error converting DependencyId to ObjectID: %w", err)
		}

		dependencyIds[i] = objectId
	}

	// Log the dependencyIds
	fmt.Printf("Dependency IDs: %v", dependencyIds)

	// Perform a lookup to verify that each DependencyId is present in trackedCVEsCollection
	pipeline := mongo.Pipeline{
		{{"$match", bson.M{"_id": bson.M{"$in": dependencyIds}}}},
		{{"$count", "count"}},
	}

	// Log the pipeline
	fmt.Printf("Aggregation Pipeline: %v", pipeline)

	cursor, err := trackedCVEsCollection.Aggregate(ctx, pipeline)
	if err != nil {
		return fmt.Errorf("error performing lookup to verify dependencies: %w", err)
	}
	defer cursor.Close(ctx)

	var result struct {
		Count int `bson:"count"`
	}

	if cursor.Next(ctx) {
		if err := cursor.Decode(&result); err != nil {
			return fmt.Errorf("error decoding lookup result: %w", err)
		}
	}

	if result.Count != len(dependencyIds) {
		return fmt.Errorf("one or more DependencyIds not found in tracked CVEs")
	}

	// Create the filter and update
	filter := bson.M{"user_id": userId}
	update := bson.M{"$set": bson.M{"dependencies_with_integration": userDeps}}
	opts := options.Update().SetUpsert(true)

	resultUpdate, err := userDependenciesCollection.UpdateOne(ctx, filter, update, opts)
	if err != nil {
		fmt.Printf("Failed to update user dependencies for user %s: %v", userId, err)
		return err
	}

	if resultUpdate.MatchedCount == 0 {
		fmt.Printf("No documents matched the filter for user %s", userId)
	}

	if resultUpdate.UpsertedCount > 0 {
		fmt.Printf("Upserted a new document for user %s", userId)
	} else if resultUpdate.ModifiedCount > 0 {
		fmt.Printf("Successfully updated user dependencies for user %s", userId)
	} else {
		fmt.Printf("No documents were modified for user %s", userId)
	}

	return nil
}
