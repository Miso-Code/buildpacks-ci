package core

import (
	"context"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/common"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services"
	"go.mongodb.org/mongo-driver/mongo"
)

func UpdateTrackedDependencies(librariesUtil common.LibrariesUtil) ([]string, []string, error) {
	mongoClient, ctx, err := librariesUtil.MongoLibrary.GetMongoClient()
	if err != nil {
		return nil, nil, err
	}

	dependenciesInFile, err := librariesUtil.CSVReaderLibrary.GetDependenciesList()
	if err != nil {
		return nil, nil, err
	}

	trackedDependencies, err := librariesUtil.MongoLibrary.GetTrackedDependencies(ctx, mongoClient)
	if err != nil {
		return nil, nil, err
	}

	addedDependencies := getAddedDependencies(trackedDependencies, dependenciesInFile)
	removedDependencies := getRemovedDependencies(trackedDependencies, dependenciesInFile)

	err = addDependencyCVEs(ctx, mongoClient, librariesUtil, addedDependencies)
	if err != nil {
		return nil, nil, err
	}

	err = removeDependencyCVEs(ctx, mongoClient, librariesUtil, removedDependencies)
	if err != nil {
		return nil, nil, err
	}

	var (
		addedDeps   []string
		removedDeps []string
	)

	for _, dependency := range addedDependencies {
		addedDeps = append(addedDeps, dependency.Product)
	}

	for _, dependency := range removedDependencies {
		removedDeps = append(removedDeps, dependency.Product)
	}

	return addedDeps, removedDeps, nil
}

func removeDependencyCVEs(ctx context.Context, client *mongo.Client, librariesUtil common.LibrariesUtil, removedDependencies []services.Dependency) error {
	err := librariesUtil.MongoLibrary.RemoveTrackedDependencies(ctx, client, removedDependencies)
	if err != nil {
		return err
	}
	return nil
}

func addDependencyCVEs(ctx context.Context, client *mongo.Client, librariesUtil common.LibrariesUtil, addedDependencies []services.Dependency) error {
	err := librariesUtil.MongoLibrary.AddTrackedDependencies(ctx, client, addedDependencies)
	if err != nil {
		return err
	}
	return nil
}

func getAddedDependencies(trackedDependencies []services.Dependency, dependenciesInFile []services.DepList) []services.Dependency {

	var addedDeps []services.Dependency

	for _, depInFile := range dependenciesInFile {
		tracked := false

		for _, trackedDep := range trackedDependencies {
			if depInFile.Vendor == trackedDep.Vendor {
				tracked = true
			}
		}

		if !tracked {
			addedDeps = append(addedDeps, services.Dependency{
				Dependency: depInFile.Product,
				Vendor:     depInFile.Vendor,
				Product:    depInFile.Product,
			})
		}

	}

	return addedDeps
}

func getRemovedDependencies(trackedDependencies []services.Dependency, dependenciesInFile []services.DepList) []services.Dependency {
	var removedDeps []services.Dependency

	for _, trackedDep := range trackedDependencies {
		tracked := false

		for _, depInFile := range dependenciesInFile {
			if trackedDep.Vendor == depInFile.Vendor {
				tracked = true
			}
		}

		if !tracked {
			removedDeps = append(removedDeps, trackedDep)
		}
	}

	return removedDeps
}
