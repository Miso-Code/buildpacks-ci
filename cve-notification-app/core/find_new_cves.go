package core

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/common"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/utils"

	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

func FindNewCVEs(librariesUtil common.LibrariesUtil) (string, error) {

	var newCves []services.CVE

	mongoClient, ctx, err := librariesUtil.MongoLibrary.GetMongoClient()
	if err != nil {
		return "", err
	}

	trackedDependencies, err := librariesUtil.MongoLibrary.GetUniqueDependencies(ctx, mongoClient)
	if err != nil {
		return "", err
	}

	for _, trackedDep := range trackedDependencies {
		cves, err := librariesUtil.NvdNistLibrary.GetCVEs(trackedDep.Vendor, trackedDep.Product)
		if err != nil {
			fmt.Println(fmt.Sprintf("Error getting CVEs for %s/%s", trackedDep.Vendor, trackedDep.Product))
			continue
		}

		for _, cveItem := range cves {
			exists, err := librariesUtil.MongoLibrary.CVEExists(ctx, mongoClient, cveItem.CVE.Id)
			if err != nil {
				fmt.Println(fmt.Sprintf("Error checking if CVE %s exists", cveItem.CVE.Id))
				continue
			}

			if !exists {
				cveSeverity, cveScore := utils.GetCVESeverity(cveItem.CVE)

				cveDescription := utils.GetCVEDescription(cveItem.CVE)

				cve := services.CVE{
					ID:          primitive.NewObjectID(),
					CreatedAt:   time.Now(),
					UpdatedAt:   time.Now(),
					Vendor:      trackedDep.Vendor,
					Product:     trackedDep.Product,
					Severity:    cveSeverity,
					Score:       cveScore,
					CVEId:       cveItem.CVE.Id,
					Description: cveDescription,
				}

				err = librariesUtil.MongoLibrary.CreateCVE(ctx, mongoClient, &cve)
				if err != nil {
					fmt.Println(fmt.Sprintf("Error creating CVE %s", cve.CVEId))
					continue
				}

				if librariesUtil.SlackLibrary != nil {
					err = librariesUtil.SlackLibrary.SendNewCVENotification(cve.Product, cve.CVEId, cve.Description, cve.Severity, cve.Score)
					if err != nil {
						fmt.Println(fmt.Sprintf("Error sending Slack notification for CVE %s", cve.CVEId))
						continue
					}
				}

				newCves = append(newCves, cve)
			}
		}

		time.Sleep(2 * time.Second)
	}

	err = librariesUtil.MongoLibrary.DisconnectMongoClient(mongoClient, ctx)
	if err != nil {
		return "", err
	}

	if len(newCves) > 0 {
		jsonOutput, err := generateJSONOutput(newCves)
		if err != nil {
			return "", err

		}
		return jsonOutput, nil
	} else {
		return "", nil
	}
}

// generateJSONOutput formats the JSON output to be more readable
func generateJSONOutput(newCves []services.CVE) (string, error) {
	jsonBytes, err := json.MarshalIndent(newCves, "", "  ")
	if err != nil {
		return "", fmt.Errorf("error marshaling json object\n%w", err)
	}

	return string(jsonBytes), nil
}
