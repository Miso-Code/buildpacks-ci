package core_test

import (
	"bytes"
	contextPkg "context"
	"fmt"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/common"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/core"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services"
	"github.com/Miso-Code/buildpacks-ci/cve-notification-app/services/servicesfakes"
	"github.com/sclevine/spec"
	"github.com/sclevine/spec/report"
	assertpkg "github.com/stretchr/testify/assert"
	requirepkg "github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/mongo"
	"os"
	"testing"
)

func TestFindNewCVESTask(t *testing.T) {
	spec.Run(t, "Finds New CVEs Task", testFindNewCVESTask, spec.Report(report.Terminal{}))
}

func testFindNewCVESTask(t *testing.T, context spec.G, it spec.S) {
	var (
		assert             = assertpkg.New(t)
		require            = requirepkg.New(t)
		allUtils           common.LibrariesUtil
		fakeMongoLibrary   *servicesfakes.FakeMongoLibraryInterface
		fakeNVDNistLibrary *servicesfakes.FakeNVDNistLibraryInterface
		fakeSlackLibrary   *servicesfakes.FakeSlackLibraryInterface
		mClient            *mongo.Client
		ctx                contextPkg.Context
	)

	it.Before(func() {
		fakeMongoLibrary = &servicesfakes.FakeMongoLibraryInterface{}
		fakeNVDNistLibrary = &servicesfakes.FakeNVDNistLibraryInterface{}
		fakeSlackLibrary = &servicesfakes.FakeSlackLibraryInterface{}

		allUtils = common.LibrariesUtil{
			MongoLibrary:   fakeMongoLibrary,
			NvdNistLibrary: fakeNVDNistLibrary,
			SlackLibrary:   fakeSlackLibrary,
		}

		mClient = &mongo.Client{}
		ctx = contextPkg.TODO()
		fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)
		fakeMongoLibrary.DisconnectMongoClientReturns(nil)
	})

	context("Calls the FindNewCVEs method", func() {
		context("succeed", func() {
			context("with new CVEs", func() {
				it.Before(func() {
					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
							Score:       7.0,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
							Score:       3.0,
						},
					})

					cves2 := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE3Id,
							Description: common.TestingCVE3Description,
							Severity:    common.CVESeverityCritical,
							Score:       10.0,
						},
						{
							Id:          common.TestingCVE4Id,
							Description: common.TestingCVE4Description,
							Severity:    common.CVESeverityCritical,
							Score:       10.0,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturnsOnCall(0, cves, nil)
					fakeNVDNistLibrary.GetCVEsReturnsOnCall(1, cves2, nil)

					fakeMongoLibrary.CVEExistsReturnsOnCall(0, true, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(1, false, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(2, true, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(3, false, nil)

					fakeMongoLibrary.CreateCVEReturns(nil)
					fakeSlackLibrary.SendNewCVENotificationReturns(nil)
				})

				it("Finds new cves for the tracked dependencies", func() {
					newCve, err := core.FindNewCVEs(allUtils)
					require.NoError(err)

					assert.Equal(2, fakeMongoLibrary.CreateCVECallCount())

					_, _, createdCve1 := fakeMongoLibrary.CreateCVEArgsForCall(0)
					assert.Equal("haxx", createdCve1.Vendor)
					assert.Equal("curl", createdCve1.Product)
					assert.Equal(common.CVESeverityLow, createdCve1.Severity)
					assert.Equal(common.TestingCVE2Id, createdCve1.CVEId)
					assert.Equal(common.TestingCVE2Description, createdCve1.Description)

					_, _, createdCve2 := fakeMongoLibrary.CreateCVEArgsForCall(1)
					assert.Equal("golang", createdCve2.Vendor)
					assert.Equal("go", createdCve2.Product)
					assert.Equal(common.CVESeverityCritical, createdCve2.Severity)
					assert.Equal(common.TestingCVE4Id, createdCve2.CVEId)
					assert.Equal(common.TestingCVE2Description, createdCve2.Description)

					assert.Equal(2, fakeSlackLibrary.SendNewCVENotificationCallCount())

					product, id, description, severity, score := fakeSlackLibrary.SendNewCVENotificationArgsForCall(0)
					assert.Equal("curl", product)
					assert.Equal(common.TestingCVE2Id, id)
					assert.Equal(common.TestingCVE2Description, description)
					assert.Equal(common.CVESeverityLow, severity)
					assert.Equal(3.0, score)

					product2, id2, description2, severity2, score := fakeSlackLibrary.SendNewCVENotificationArgsForCall(1)
					assert.Equal("go", product2)
					assert.Equal(common.TestingCVE4Id, id2)
					assert.Equal(common.TestingCVE2Description, description2)
					assert.Equal(common.CVESeverityCritical, severity2)
					assert.Equal(10.0, score)

					assert.Contains(newCve, common.TestingCVE2Id, "newCve should contain CVE-2")
					assert.Contains(newCve, common.TestingCVE4Id, "newCve should contain CVE-4")
					assert.NotContains(newCve, common.TestingCVE1Id, "newCve should not contain CVE-1")
					assert.NotContains(newCve, common.TestingCVE3Id, "newCve should not contain CVE-3")
				})
			})

			context("without new CVEs", func() {
				it.Before(func() {
					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
						},
					})

					cves2 := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE3Id,
							Description: common.TestingCVE3Description,
							Severity:    common.CVESeverityCritical,
						},
						{
							Id:          common.TestingCVE4Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityCritical,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturnsOnCall(0, cves, nil)
					fakeNVDNistLibrary.GetCVEsReturnsOnCall(1, cves2, nil)

					fakeMongoLibrary.CVEExistsReturnsOnCall(0, true, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(1, true, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(2, true, nil)
					fakeMongoLibrary.CVEExistsReturnsOnCall(3, true, nil)

					fakeMongoLibrary.CreateCVEReturns(nil)
					fakeSlackLibrary.SendNewCVENotificationReturns(nil)
				})

				it("Did not find new cves for the tracked dependencies", func() {
					newCve, err := core.FindNewCVEs(allUtils)
					require.NoError(err)

					assert.Equal(0, fakeMongoLibrary.CreateCVECallCount())
					assert.Equal(0, fakeSlackLibrary.SendNewCVENotificationCallCount())
					assert.Equal("", newCve)
				})
			})
		})

		context("fails", func() {
			context("getting mongo client", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(nil, nil, fmt.Errorf("client"))
				})

				it(common.ReturnsError, func() {
					_, err := core.FindNewCVEs(allUtils)
					require.Error(err)

					assert.EqualError(err, "client")
				})
			})

			context("getting unique dependencies", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)
					fakeMongoLibrary.GetUniqueDependenciesReturns(nil, fmt.Errorf("unique-dependencies"))
				})

				it(common.ReturnsError, func() {
					_, err := core.FindNewCVEs(allUtils)
					require.Error(err)

					assert.EqualError(err, "unique-dependencies")
				})
			})

			context("getting CVEs", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)

					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)
					fakeNVDNistLibrary.GetCVEsReturns([]services.NVDNistResponseCVEItem{}, fmt.Errorf("cves"))
				})

				it(common.LogWarning, func() {
					output := captureOutput(func() {
						newCves, err := core.FindNewCVEs(allUtils)
						assert.Equal("", newCves)
						require.NoError(err)
					})

					assert.Contains(output, "Error getting CVEs for haxx/curl")
					assert.Contains(output, "Error getting CVEs for golang/go")
				})
			})

			const CVEShouldContainCVE1Haxx = "newCves should contain CVE-1 for haxx/curl"
			const CVEShouldContainCVE1Go = "newCves should contain CVE-1 for golang/go"
			const CVEShouldContainCVE2Go = "newCves should contain CVE-2 for golang/go"
			context("creating CVE in database", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)

					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturns(cves, nil)

					fakeMongoLibrary.CreateCVEReturnsOnCall(1, fmt.Errorf("create-cve"))
				})

				it(common.LogWarning, func() {
					output := captureOutput(func() {
						newCves, err := core.FindNewCVEs(allUtils)
						require.NoError(err)

						assert.Contains(newCves, "\"Vendor\": \"haxx\",\n    \"Product\": \"curl\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Haxx)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Go)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"LOW\",\n    \"CVEId\": \"CVE-2\"", CVEShouldContainCVE2Go)
					})

					assert.Contains(output, "Error creating CVE CVE-2")
				})
			})

			context("finding CVE in database", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)

					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturns(cves, nil)

					fakeMongoLibrary.CVEExistsReturnsOnCall(1, false, fmt.Errorf("create-cve"))
				})

				it(common.LogWarning, func() {
					output := captureOutput(func() {
						newCves, err := core.FindNewCVEs(allUtils)
						require.NoError(err)

						assert.Contains(newCves, "\"Vendor\": \"haxx\",\n    \"Product\": \"curl\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Haxx)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Go)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"LOW\",\n    \"CVEId\": \"CVE-2\"", CVEShouldContainCVE2Go)
					})

					assert.NotContains(output, "Error checking if CVE CVE-1 exists")
					assert.Contains(output, "Error checking if CVE CVE-2 exists")
				})
			})

			context("sending slack message", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)

					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturns(cves, nil)

					fakeMongoLibrary.CVEExistsReturns(false, nil)
					fakeMongoLibrary.CreateCVEReturns(nil)

					fakeSlackLibrary.SendNewCVENotificationReturnsOnCall(1, fmt.Errorf("slack-notification"))
				})

				it(common.ReturnsError, func() {
					output := captureOutput(func() {
						newCves, err := core.FindNewCVEs(allUtils)
						require.NoError(err)

						assert.Contains(newCves, "\"Vendor\": \"haxx\",\n    \"Product\": \"curl\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Haxx)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"HIGH\",\n    \"CVEId\": \"CVE-1\"", CVEShouldContainCVE1Go)
						assert.Contains(newCves, "\"Vendor\": \"golang\",\n    \"Product\": \"go\",\n    \"Severity\": \"LOW\",\n    \"CVEId\": \"CVE-2\"", CVEShouldContainCVE2Go)
					})

					assert.NotContains(output, "Error sending Slack notification for CVE CVE-1")
					assert.Contains(output, "Error sending Slack notification for CVE CVE-2")
				})
			})

			context("disconnecting mongo client", func() {
				it.Before(func() {
					fakeMongoLibrary.GetMongoClientReturns(mClient, ctx, nil)

					trackedDeps := []services.CVE{
						{
							Vendor:  "haxx",
							Product: "curl",
						},
						{
							Vendor:  "golang",
							Product: "go",
						},
					}

					fakeMongoLibrary.GetUniqueDependenciesReturns(trackedDeps, nil)

					cves := services.GenerateFakeCVE([]services.FakeCVEParam{
						{
							Id:          common.TestingCVE1Id,
							Description: common.TestingCVE1Description,
							Severity:    common.CVESeverityHigh,
						},
						{
							Id:          common.TestingCVE2Id,
							Description: common.TestingCVE2Description,
							Severity:    common.CVESeverityLow,
						},
					})

					fakeNVDNistLibrary.GetCVEsReturns(cves, nil)

					fakeMongoLibrary.CVEExistsReturns(false, nil)
					fakeMongoLibrary.CreateCVEReturns(nil)

					fakeSlackLibrary.SendNewCVENotificationReturns(nil)
					fakeMongoLibrary.DisconnectMongoClientReturns(fmt.Errorf("disconnect"))
				})

				it(common.ReturnsError, func() {
					_, err := core.FindNewCVEs(allUtils)
					require.Error(err)

					assert.EqualError(err, "disconnect")
				})
			})
		})
	})
}

func captureOutput(f func()) string {
	// Save the original stdout
	origStdout := os.Stdout
	defer func() { os.Stdout = origStdout }()

	// Create a pipe to capture stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	// Run the function
	f()

	// Close the writer and read the output
	w.Close()
	var buf bytes.Buffer
	_, _ = buf.ReadFrom(r)

	return buf.String()
}
